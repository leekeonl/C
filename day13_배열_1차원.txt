#include <stdio.h>

void main(){

	/*
	배열
	 : 같은 자료형으로 만들어진 여러개의 연속된 공간을 하나의 변수 이름으로 사용하는 것.
	   하나의 대표 이름으로 형식이 같은 여러 개의 자료를 관리하기 위한
	   데이터 저장 방법이라 할 수 있다.

	장점 :
	  1. 메모리상에 연달아 빈틈없이 만들어 짐으로 변수를 따로 만드는 것
   	     보다 메모리를 절약 할 수 있다.
	  2. 하나의 대표 이름으로 변수 여러 개에 해당하는 기억장소를 한 번에
  	     할 당 받을 수 있으므로 일괄적인 처리가 가능하다.

 	만드는 방법과 사용 방법
	  : 배열을 만들기 위해서는 일반 변수와 동일한 방법으로 만들되 변수명
	    뒤쪽에 [배열의 크기]를 붙인다.
	    
	    ex ) 1 자료형 2 배열명 [3배열의 크기]
		    int      arr       [4];
	
	         -> 위와 같이 선언하면 자료형이 int인 변수 4개가 보관될 수 
		    있도록 16byte의 메모리가 할당 되면서, 공간이 시작하는 곳의
		    주소가 배열명 arr에 보관 된다.
		 -> 배열명 arr의 의미
		     1. 배열의 제일 첫 번째 주소를 타나낸다.
		     2. 배열의 전체 크기를 나타낸다.	

	    ex ) 배열의 초기화 및 메모리상의 구성		
		  				-----------------------------------------
		int num[5] = { 1,2,3,4,5 };     |   1	|   2	|   3	|   4	|   5	|		
						-----------------------------------------
					   num    num[0]  num[1]  num[2]  num[3]  num[4] 

		  				-----------------------------------------
		int num[ ] = { 1,2,3,4,5 };     |   1	|   2	|   3	|   4	|   5	|		
						-----------------------------------------
					   num	  num[0]  num[1]  num[2]  num[3]  num[4] 

		  				-----------------------------------------
		int num[5] = { 3,4 };    	|   3	|   4	|   0	|   0	|   0	|		
						-----------------------------------------
					   num	  num[0]  num[1]  num[2]  num[3]  num[4] 

		  				-----------------------------------------
		char ch[ ] = "AB C";		|   A	|   B	|   	|   C	|   \0	|		
						-----------------------------------------
					    ch	   ch[0]   ch[1]   ch[2]   ch[3]   ch[4] 
		※ 문자열 배열 \0 
		    : 문자열을 입력 할 때는 문자열의 끝을 알리는 NULL(=\0)문자가 자동 삽입 된다.
		      아스키코드 상에서는 '0' 과 같다.
	    
	*/

	// 배열 초기화시 주의 할 점
	/*
	int   n2[2] = { 10, 20 };		// 초기화 가능
	int   n3[2];
	// n3[2] = {100, 200};	// 초기화 불가능 => 에러 발생!!

	n3[0] = 100;	n3[1] = 200;
	*/

	// 배열 원소의 출력
	/*
	int   n1[3] = { 1, 2, 3 };
	int   n2[2];

	n2[0] = 4;
	n2[1] = 5;
	n2[0] = 6, n2[1]=7;

	printf("n1 첫번째 데이터 : %d \n",  n1[0] );
	printf("n1 두번째 데이터 : %d \n",  n1[1] );
	printf("n1 세번째 데이터 : %d \n",  n1[2] );
	
	printf("n2 첫번째 데이터 : %d \n",  n2[0] );
	printf("n2 두번째 데이터 : %d \n",  n2[1] );
	
	n2[0] = 6, n2[1]=7;
	printf("n2 모든 데이터 : %d, %d \n",  n2[0], n2[1] );
	printf("n2의 주소 값 : %d \n", n2); 
	*/

	
	// for문을 이용한 배열 원소의 일괄적인 출력
	/*
	int m[3] = { 10, 20, 30 };
	int i;

	for( i=0 ; i<3 ; i++ )
	     printf("배열 m의 %d번째 원소 : %d\n", i, m[i]);
	*/ 

	// 두 원소의 합
	/*
	int   n1[5] = { 1, 2, 3, 4, 5 };
	int   n2[3] = { 10, 20, 30 };

	// n1의 3과  n2의 30을 더한 결과를 출력하세요.
	printf("n1의 3 + n2의 30 = %d  \n",  n1[2] + n2[2] );

	// n1의 5와  n2의 10을 더한 결과를 출력하세요.
	printf("n1의 5 + n2의 10 = %d  \n",  n1[4] + n2[0] );

	// n1의 4와  n2의 20을 더한 결과를 출력하세요.
	printf("n1의 4 + n2의 20 = %d  \n",  n1[3] + n2[1] );

	// n1의 2와  n2의 30을 더한 결과를 출력하세요.
	printf("n1의 2 + n2의 30 = %d  \n",  n1[1] + n2[2] );
	*/
	
	// 배열에 담긴 값들의 합
	/*
	int M[4]= {5, 3, 13, 4};
	int a, sum=0;
      
	for(a=0; a<4; a++){
		printf("%d+", M[a]);
		sum += M[a];
		}
	printf(“\b %d\n", sum);
	*/

	// 배열에 담긴 값들 중에서 최대값, 최소값
	/*
	int M[4]= {5, 3, 40, 7};
	int a, big, small;

	big = small = M[0];

	for( a=1 ; a<4 ; a++ ) {
		if ( M[a] > big ) 
			big = M[a];
		if ( M[a] < small ) 
			small = M[a];
	}
	printf("최대값 = %d, 최소값 = %d\n", big,  small);
	*/
	
	// 배열에 담긴 요소 값들 중에서 10~19사이의 값들이 개수
	/*
	int M[8]= {10, 27, 25, 19, 9, 35, 13, 47 };
	int a;
	int cnt=0;

	for( a=0  ; a<8 ; a++ ) {
		if ( M[a] >= 10 && M[a]<=19 ) 
			cnt++;
	}
	printf("%d개\n", cnt );

	*/

	

}